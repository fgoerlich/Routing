---
title: "Distancias y Tiempos"
subtitle: "üåé <br/><br/>con _R_"
author: "Francisco Goerlich"
institute: "Universidad de Valencia e Ivie"
date: "??/06/2021"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include = FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(message = FALSE, warning = FALSE, fig.align = "center")
xaringanExtra::use_tachyons()
xaringanExtra::use_tile_view()
```

# Contexto...

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "100%", fig.align = "center"}
knitr::include_graphics("./img/01_MonoFRA.jpg")
```

<br>

Cualquier ejercicio de accesibilidad (geogr√°fica) tiene (al menos) 3 patas:

1. un **origen** por parte de quien accede,

1. una **ruta**, por alg√∫n medio de trasporte determinado, y

1. un **destino** al centro donde se accede.

--

Ya vimos como geocodificar destinos. ¬°Como empezamos la casa por el tejado!, seguimos ahora con la determinaci√≥n de la ruta para un **origen dado**. 

¬°En realidad solo estaremos interesados en distancias y tiempos de viaje!

---

# Preliminares (1/2)

Los problemas de rutas pueden ser extremadamente complejos.

Si queremos ir de _A_ a _B_, ¬øcomo queremos ir?

En coche, a pie, en bicicleta, en tren, en barco --¬øes posible?--, en avi√≥n.

¬øEn un √∫nico medio de transporte o combinando varios?

¬øPodemos ir en l√≠nea recta o debemos utilizar una red?

Nos interesa solo la distancia y el tiempo aproximado que tardaremos, o queremos saber los puntos de paso, es decir la **ruta**.

--

¬°Debemos ser espec√≠ficos sobre todas estas cuestiones **antes** de empezar!

---

# Preliminares (2/2)

Normalmente no podremos ir en linea recta, de forma que **necesitaremos una red de transporte**.

--

Si solo vamos a utilizar un modo de transporte tenemos un problema de **red unimodal**, y solo necesitaremos la red del modo de transporte correspondiente, la red de carreteras o de ferrocarril.

--

Si vamos a utilizar varios modos de transporte tenemos un problema de **red multimodal**, y necesitaremos los puntos de intercambio.

--

Si **no** somos aut√≥nomos en el medio de transporte elegido &ndash;coche, bicicleta, a pie,...&ndash; deberemos disponer de las frecuencias de paso y los puntos de parada.

--

Nuestro ejercicio lo simplifica todo al m√°ximo. Queremos conocer la **distancia** y el **tiempo de viaje** aproximado entre dos puntos concretos en **coche privado** utilizando la **red de carreteras**.

--

**¬°Recordar!** Las distancias son siempre m√°s fiable que los tiempos de viaje, puesto que las primeras son algo f√≠sico, que se miden sobre la red, mientras que los segundos dependen de supuestos sobre velocidades del medio de transporte y las condiciones de tr√°fico.

---

### Retomamos el problema donde lo dejamos...

```{r echo = FALSE, out.width = "100%", fig.height = 6, eval = require("leaflet")}
IvieIcon <- makeIcon(iconUrl = "https://www.ivie.es/wp-content/uploads/2017/02/logo.jpg",
                     iconWidth = 45, iconHeight = 25,
                     iconAnchorX = 15, iconAnchorY = 25)

Oficinas <- sf::read_sf("./data/Oficinas2020geoIvie.gpkg") %>%
  sf::st_transform(crs = 4326)

route <- osrm::osrmRoute(src = c(-0.3559, 39.4805), dst = Oficinas[188, ], returnclass = "sf", osrm.profile = "foot")
leaflet() %>% addTiles() %>% setView(lng = -0.3594, lat = 39.4805, zoom = 16) %>%
  addMarkers(lng = -0.3559, lat = 39.4805, icon = IvieIcon) %>%
  addMarkers(data = Oficinas, clusterOptions = markerClusterOptions(), popup = Oficinas$Entidad) %>%
  addPolylines(data = route, color = "red") %>%
  addLabelOnlyMarkers(lng = -0.3587, lat = 39.4807, label = "1km & 12m", labelOptions = labelOptions(noHide = TRUE,
                      textOnly = TRUE, style = list("color" = "red"), textsize = "12px"))
```

---

# _CRS: Coordinate Reference Systems_

La informaci√≥n geogr√°fica siempre est√° necesariamente ligada a un **Sistema de Referencia de Coordenadas (_CRS_)**. Hay b√°sicamente 2 grupos de _CRS_.

--

.pull-left[
**Geogr√°ficos**

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "80%", fig.align = "center"}
knitr::include_graphics("./img/vector_lonlat.png")
```

]

--

.pull-right[
**Proyectados**

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "80%", fig.align = "center"}
knitr::include_graphics("./img/vector_projected.png")
```

]

--

**IMPORANTE:** Siempre que trabajemos con informaci√≥n geogr√°fica debemos asegurarnos que **toda la informaci√≥n** est√° en el **mismo _CRS_**.


???

Afortunadamente los servicios que utilizaremos se encargar√°n de gran parte de estas cosas y nosotros no tendremos que preocuparnos.

---

class: inverse, center, middle

# Get Started

---

# Problema real

Disponemos del fichero de Oficinas bancarias de diciembre de 2020 del Banco de Espa√±a georeferenciado y queremos estimar la **distancia** y el **tiempo** de acceso de **cada municipio** a la **oficina m√°s cercana**.

--

**Importante:** Las distancias se miden entre puntos, por tanto el municipio es un punto, la coordenada de la capital. Implicitamente suponemos que la poblaci√≥n est√° concentrada en ese punto.

--

¬øCual es la dimensi√≥n de nuestro problema?

**Origenes:** 8 131 municipios.
**Destinos:** 22 558 oficinas.

--

La matriz de **O**rigen-**D**estino (OD) tiene 183 419 098 celdas.

¬°Debemos calcular m√°s de 183 millones de rutas y elegir la √≥ptima para cada municipio!

--

Claramente debemos reducir la dimensi√≥n de nuestro problema.

---

# Problemas a resolver

Tenemos, pues, 2 problemas a resolver:

--

1. Dados dos puntos debemos calcular la **ruta √≥ptima** (menor distancia/tiempo).

--

1. Debemos **acotar** el conjunto de **candidatos posibles** para el calculo de rutas hasta una dimensi√≥n razonable. 

--

¬°Como siempre empezamos por el final!

--

<br>

Acotar el conjunto de oficinas candidatas a las mas cercanas de un municipio puede hacerse mediante lo que en _GIS_ se conoce como determinaci√≥n de **√°reas de influencia**, ¬°y naturalmente no hay una forma √∫nica de hacerlo!

---

# ¬ø√Åreas de influencia?

- Si **no disponemos de la red** es posible dividir, de forma **√≥ptima**<sup>*</sup>, el territorio en tantos poligonos como destinos tengamos -oficinas en nuestro caso- y asignar los or√≠genes a dichos pol√≠gonos. Una forma de hacer esto es la [teselaci√≥n de Voronoi](http://alexbeutel.com/webgl/voronoi.html) ([sf::st_voronoi](https://r-spatial.github.io/sf/reference/geos_unary.html)).

.footnote[(*) Por √≥ptima entendemos que las lineas que determinan los pol√≠gonos son equidistantes a los puntos.]

--

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "45%", fig.align = "center"}
knitr::include_graphics("./img/02_Voronoi.png")
```

---

# ¬ø√Åreas de influencia?

- ¬øOtros m√©todos? **Si**. Incluso si seguimos **sin disponer de la red**.

```{r echo = FALSE, out.width = "100%", fig.height = 6}
leaflet(Oficinas) %>% addTiles() %>% setView(lng = -0.3559, lat = 39.4805, zoom = 15) %>%
  addMarkers(popup = ~ Entidad) %>%
  addMarkers(lng = -0.3559, lat = 39.4805, icon = IvieIcon) %>%
  addCircles(lng = -0.3559, lat = 39.4805, radius = 600)
```


---

# ¬ø√Åreas de influencia?

- **Si disponemos de la red** podemos afinar el m√©todo anterior. Podemos trazar un pol√≠gono a partir de los ejes de la red.

--

```{r, echo = FALSE, eval = TRUE, out.width = "75%", fig.align = "center"}
knitr::include_graphics("./img/03_Area_Influencia.png")
```

---

# √Åreas de influencia: [Cartociudad](https://www.cartociudad.es/portal/) 

```{r, eval = FALSE}
#   √Årea de influencia a partir de la red de Cartociudad
cartociudad_get_area <- function(longitud, latitud, distancia, plot = FALSE)
```

```{r, echo = FALSE, eval = TRUE, out.width = "70%", fig.align = "center"}
knitr::include_graphics("./img/04_Area_Influencia.png")
```

---

# √Åreas de influencia: Monograf√≠a accesibilidad

- ¬øC√≥mo se generaron las √°reas de influencia en la monograf√≠a de accesibilidad?

<br>

--

- Dos casos:

 1. Si el **municipios tiene oficina** el **√°rea de influencia** es el propio **t√©rmino municipal**.

 1. Si el **municipio no tiene oficina** el **√°rea de influencia** viene determinada por un n√∫mero determinado de **municipios vecinos**, entendidos como otros municipios con contig√ºidad f√≠sica, con oficinas.

---

# Municipios **con** Oficina

.pull-left[ 

```{r, echo = FALSE, eval = TRUE, out.width = "80%", fig.align = "center"}
knitr::include_graphics("./img/05_ValOfi.jpg")
```

]

.pull-right[ 
- En el caso de los **municipios con oficina** se calcular√°n distancias y tiempos a todas las oficinas del t√©rmino municipial, que constituye su propia √°rea de influencia.

<br>

- El **supuesto impl√≠cito** es que el acceso es a las oficinas del propio t√©rmino municipal, de forma que no buscamos oficinas en otros municipios.

]

---

# Municipios **sin** Oficina

- En el caso de los **municipios sin oficina** el umbral de municipios vecinos en los que buscar la oficina m√°s cercana se fij√≥ en 20.

- El **supuesto impl√≠cito** es que la oficina m√°s cercana al municipio en cuesti√≥n que carece de oficina est√° en los 20 vecinos m√°s pr√≥ximos que tienen oficina.

--

- La b√∫squeda de vecinos se hace por contiguidad f√≠sica del t√©rmino municipal, iterativamente a partir de la contig√ºidad de primer orden, hasta completar al menos 20 vecinos con oficinas.

- El algoritmo de b√∫squeda implica que tendremos, al menos, 20 municipios vecinos &ndash;de un orden de contig√ºidad no identificado a priori&ndash; con oficina, y al menos 20 candidatos &ndash;oficinas&ndash;, pero normalmente muchas m√°s.

---

# ¬øComo buscamos los vecinos?

- A partir del mapa de contornos municipales una funci√≥n hace el trabajo:

```{r, eval = FALSE}
# Given a POLYGON or MULTIPOLYGON sf and a primary key,
# it generates a list with the neighboring codes.
neighbor_codes <- function(poly, variable, type = c('queen', 'rook', 'bishop')) {
```

<br>

- Existen varios tipos de contig√ºidad, _queen_, _rook_ y _bishop_, y consideramos el menos restrictivo.

```{r, echo = FALSE, eval = TRUE, out.width = "80%", fig.align = "center"}
knitr::include_graphics("./img/06_Neighbors.png")
```

---

# Visualmente: Municipio **sin** oficina

```{r, echo = FALSE, eval = TRUE, out.width = "90%", fig.align = "center"}
knitr::include_graphics("./img/07_Vecinos.jpg")
```

---

# Vecinos de **primer orden**

```{r, echo = FALSE, eval = TRUE, out.width = "90%", fig.align = "center"}
knitr::include_graphics("./img/08_Vecinos.jpg")
```

---

# Vecinos de **segundo orden**

```{r, echo = FALSE, eval = TRUE, out.width = "90%", fig.align = "center"}
knitr::include_graphics("./img/09_Vecinos.jpg")
```

---

# Vecinos de **tercer orden**

```{r, echo = FALSE, eval = TRUE, out.width = "90%", fig.align = "center"}
knitr::include_graphics("./img/10_Vecinos.jpg")
```

---

# ¬°Solo si tienen oficina cuentan en el umbral!

```{r, echo = FALSE, eval = TRUE, out.width = "90%", fig.align = "center"}
knitr::include_graphics("./img/11_Vecinos.jpg")
```

---

# Municipio y su √°rea de influencia

```{r, echo = FALSE, eval = TRUE, out.width = "90%", fig.align = "center"}
knitr::include_graphics("./img/12_Vecinos.jpg")
```

---

# Distancias y tiempos.

- Una vez tenemos or√≠genes &ndash;municipios&ndash; y destinos candidatos &ndash;oficinas&ndash; estamos en disposici√≥n de calcular **distancias** y **tiempos de viaje**.

- Para ello necesitamos una **red de carreteras** con los atributos respectivos. B√°scicamente las longitudes y velocidades de cada tramo.

--

- Existen 2 posibilidades para llevar a cabo este tipo de c√°lculos


`google_geocode()` y `geocodificar_google()` son **funciones an√°logas** a las de Cartociudad con (casi) id√©nticos par√°metros de entrada y el mismo formato de la respuesta, de forma que los resultados de pueden acumular con `bind_rows()`.

¬°La principal diferencia es que, dado que Google es un servicio de pago, requieren una API _key_!

Entre otras cosas, por esta raz√≥n, la geocodificaci√≥n de las oficinas bancarias primero pas√≥ por Cartociudad y luego por Google.

---

# Georeferenciaci√≥n de Oficinas: _workflow_

- Se realiza un primer paso por [Cartociudad](https://www.cartociudad.es/portal/) utilizando el poligono del municipio como control de calidad espacial ‚Äîsi la coordenada no cae dentro del municipio se desecha‚Äî

```{r, eval = FALSE}
# 01Oficinas_Carto1.R
for(i in 1:n){
  poly <- Municipios2020 %>% filter(INECodMuni == Oficinas$CodMuni[i])
  g <- geocodificar_cartociudad(Oficinas$ndir[i], poligono = poly)       #<<
  Oficinas$georef[i]  <- g$georef
  Oficinas$comment[i] <- g$comment
  if (g$georef == 'SI'){
    Oficinas$Longitud[i] <- g$lng
    Oficinas$Latitud[i]  <- g$lat
    Oficinas$Fuente[i]   <- if_else(g$version == 'prev', 'Cartociudad. Version antigua.', 'Cartociudad. Version nueva.')
    Oficinas$Comentarios[i] <- paste0(g$stateMsg, ' (', g$state, '). Lugar: ', g$muni, ' (', g$province, ').')
    Oficinas$CalidadGeocodificacion[i] <- 'Coordenada en TM.'
    Oficinas$DireccionNormalizada[i] <- normaliza_dir(g$tip_via, g$address, g$portalNumber, g$muni, g$province, g$postalCode)
  }
}
```

---

# Georeferenciaci√≥n de Oficinas: _workflow_

- Esta primera pasada georeferenci√≥ el 89.4% de las oficinas, 20 163, con lo que nos faltan por georeferenciar el 10.6% de las oficinas, 2 395.

- Si en la primera pasada no lleg√°is al 80% de tasa de √©xito, o las direcciones no est√°n bien tratadas o no tienen la suficiente calidad para acometer el proceso. ¬°Volvemos a la casilla de salida!

- ¬°Agita las direcciones y vuelvelas a pasar por Cartociudad!

--

```{r, eval = FALSE}
# 02Oficinas_Carto2.R
Oficinas <- Oficinas %>%
  mutate(vdir = agita_dir(tvia, nvia, npoli, Municipio, Provincia, CP, nivel = niv)) #<<
```

- **Agitando** las direcciones conseguimos georeferenciar 583 oficinas m√°s. ¬°Ya tenemos el 92.0%!, nos quedan 1 812 oficinas por georeferenciar, el 8.0%.

---

# Georeferenciaci√≥n de Oficinas: _workflow_

- ¬øTiene Google algo que decir? S√≠. Normalmente bastante. Las restantes las pasamos por Google, que encuentra 1 702 oficinas. ¬°Nos quedan 110!


```{r, eval = FALSE}
# 03Oficinas_Google1.R
for(j in 1:totno.geo){
  i <- no.geo[j]
  poly <- Municipios2020 %>% filter(INECodMuni == Oficinas$CodMuni[i])
  g <- geocodificar_google(Oficinas$ndir[i], clave_google = APIkey, poligono = poly) #<<
  Oficinas$georef[i]  <- g$georef
  Oficinas$comment[i] <- g$comment
  if (g$georef == 'SI'){
    Oficinas$Longitud[i] <- g$lng
    Oficinas$Latitud[i]  <- g$lat
    Oficinas$Fuente[i] <- 'Google'
    Oficinas$Comentarios[i] <- paste0(g$stateMsg, ' (', g$state, '). Lugar: ', g$muni, ' (', g$province, ').')
    Oficinas$CalidadGeocodificacion[i] <- 'Coordenada en TM.'
    Oficinas$DireccionNormalizada[i] <- normaliza_dir(g$tip_via, g$address, g$portalNumber, g$muni, g$province, g$postalCode)
  }
}
```

---

# Georeferenciaci√≥n de Oficinas: _workflow_

- Google tiene la ventaja de que admite POIs (_Points of Interest_), Cartociudad no.

- Probamos a a√±adir la `Entidad` entidad a la direcci√≥n.

```{r, eval = FALSE}
# 04Oficinas_Google2.R
# A√±adimos la Entidad al principio de la direccion
direccion <- paste0(Oficinas$Entidad[i], ', ', Oficinas$ndir[i])  #<<
g <- geocodificar_google(direccion, clave_google = APIkey, poligono = poly)
```

- Lo que encuentra 77 coordenadas adicionales.

- ¬°Nos quedan 33 oficinas por geocodificar, el 0.15%!

- Si pod√©is prescindir de 33 observaciones de 22 558 os har√©is un favor, en caso contrario solo queda hacer una investigaci√≥n individual, rebajar las exigencias, y/o acudir a la base de datos de coordenadas de respaldo. En este caso las coordenadas de la Capital del Municipio.

---

# Oficinas d√≠scolas (1/3)

Llegados a este punto podemos dudar, de forma razonable, de todas las fuentes de informaci√≥n: El geocodificador puede no encontrar la direcci√≥n, las coordenadas devueltas pueden ser incorrectas, el fichero original puede tener errores -de hecho los tiene, ¬°y muchos!‚Äî, y/o el fichero de lindes puede ser impreciso.

En este caso concreto se procedi√≥ de la siguiente forma:

- Despu√©s de pasar por Cartociudad y Google se examinaron individualmente las oficinas que no se consigui√≥ georeferenciar.

- En particular, se vi√≥ donde devolv√≠a el geocodificador coordenadas: _Spatial join_

```{r, eval = FALSE}
# 05Oficinas_Spatial_join.R
g_join <- st_as_sf(OficinasNO, coords = c('Longitud', 'Latitud'), crs = 4258) %>%
  st_join(Municipios2020)   #<<
```

---

# Oficinas d√≠scolas (2/3)

- Se hicieron b√∫squedas manuales en Google y en los buscadores de las oficinas de cada entidad.

- Ello permiti√≥ corregir numerosos errores del fichero original del Banco de Espa√±a<sup>*</sup>.

- Rebajando la precisi√≥n de la coordenada devuelta por Cartociudad, `state = 6`, se geocodific√≥ 1 oficina m√°s.

```{r, eval = FALSE}
# 06Oficinas_Carto4.R
g <- cartociudad_geocode(Oficinas$ndir[i], ver = "current", progress = FALSE)
  if (g$state == 6) # Aceptamos la coordenada con menor precisi√≥n #<<
```

- Se mantuvo el criterio de que todas las coordenadas deb√≠an "caer" en el t√©rmino municipal de acuerdo con el mapa del IGN. ¬°A√∫n a sabiendas de que el mapa no es perfecto y contiene errores!


.footnote[(*) Esto se hizo en iteraciones anteriores del proceso.]

---

# Oficinas d√≠scolas (3/3)

- Finalmente, para 32 oficinas, se asign√≥ la **coordenada de la Capital del Municipio**<sup>*</sup>.

Lo que cierra el proceso (iterativo) de georeferenciaci√≥n.

<br/>

----

.footnote[(*) Esta informaci√≥n procede del Nomencl√°tor geografico del IGN y se comprob√≥ que las coordenadas caen donde deben hacerlo.]

--

<br/>

- La distribuci√≥n final del origen de las coordenadas es



---

# Comprobaciones finales

Es **importante** realizar **dos comprobaciones finales**:

- Comprobar que **todas las coordenadas caen dentro de la precisi√≥n espacial fijada** en la estrategia inicial<sup>*</sup>.

```{r, eval = FALSE}
# 07Oficinas_final.R
OfiMuni <- Oficinas %>%
  st_as_sf(coords = c("Longitud", "Latitud"), crs = 4258) %>%
  st_intersection(Municipios2020)  # Una interseci√≥n espacial hace el trabajo #<<
sum(OfiMuni$CodMuni != OfiMuni$INECodMuni)
```

.footnote[(*) Si hay excepciones se deber√° dejar registro de ello.]

--

- Comprobar **duplicados por coordenada**. Muy √∫til para detectar errores. 

```{r, eval = FALSE}
# 07Oficinas_final.R
duplicados <- Oficinas %>%
  janitor::get_dupes(CodMuni, Municipio, CodEnt, Entidad, Longitud, Latitud) #<<
```

---

class: inverse, center, middle

# ¬øPara que sirve todo esto?

---

### Para pintar oficinas en el mapa...

```{r echo = FALSE, out.width = "100%", fig.height = 6, eval = require("leaflet")}
leaflet(Oficinas) %>% addTiles() %>% setView(lng = -0.3559, lat = 39.4805, zoom = 18) %>%
  addMarkers(lng = -0.3559, lat = 39.4805, icon = IvieIcon) %>%
  addMarkers(clusterOptions = markerClusterOptions(), popup = ~ Entidad)
```

---
background-image: url(https://www.ivie.es/wp-content/uploads/2017/02/logo.jpg), url(https://www.uv.es/recursos/fatwirepub/css/logoPeu.png)
background-position: 95% 5%, 5% 95%
background-size: 12%, 20%

class: center, middle


# ¬°Gracias por la atenci√≥n!

## .green[¬øPreguntas?]

???

Slides created via the R package [**xaringan**](https://github.com/yihui/xaringan).

